## Week23 (23.08.07 ~ 23.08.13)
| 제목 | 내 접근 | 링크 |
| :---: | :---: | :---: |
| [회의실 배정](#회의실-배정) | 그리디, 정렬 | [문제 링크](https://www.acmicpc.net/problem/1931) |
| [단어 수학](#단어-수학) | 그리디 | [문제 링크](https://www.acmicpc.net/problem/1339) |
| [길 찾기 게임](#길-찾기-게임) | 구현 | [문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/42892) |

<br>

## 회의실 배정
- [문제 링크](https://www.acmicpc.net/problem/1931)
- 문제 유형 : 그리디, 정렬
- [참고 링크](https://source-sc.tistory.com/59)

<br>

## 단어 수학
- [문제 링크](https://www.acmicpc.net/problem/1339)
- 문제 유형 : 그리디

<br>

## 길 찾기 게임
- [문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/42892)
- [해설 링크](https://tech.kakao.com/2018/09/21/kakao-blind-recruitment-for2019-round-1/#5-%EA%B8%B8-%EC%B0%BE%EA%B8%B0-%EA%B2%8C%EC%9E%84)
- 문제 유형 : 구현

> 트리를 순회하는 방법은 검색을 통해 쉽게 알 수 있으므로 문제가 되지 않습니다. 이 문제의 핵심은 좌표 값으로 주어지는 노드들을 트리로 구성하는 부분입니다.
> 
> 트리를 만들기 위해 $y$값을 이용해서 각 노드의 level 을 분리하고, 현재 노드의 자식 노드가 가질 수 있는 $x$값을 이용하여 현재 노드의 왼쪽, 오른쪽 자식을 정확히 찾는 것이 중요합니다.
> 
> 각 노드의 왼쪽, 오른쪽 자식 노드는 다음과 같이 찾을 수 있습니다.
> 
> 먼저 현재 노드 $P$의 $x$값을 $P_x$, 현재 노드의 자식 노드가 가질 수 있는 $x$범위를 $L_x, R_x (L_x < P_x < R_x)$라고 하겠습니다. 또 어떤 노드 $K$의 $x$값을 $K_x$라고 하겠습니다. 
> 
> 만약 현재 노드의 바로 다음 레벨에 $L_x ≤ K_x < P_x$를 만족하는 노드 $K$가 있다면 $K$는 노드 $P$의 왼쪽 자식이 됩니다. 이때, 노드 $K$의 자식 노드가 가질 수 있는 $x$값의 범위는 $L_x ≤ x ≤ P_x ? 1 (x ≠ K_x)$가 됩니다.
>
> 마찬가지로 현재 노드의 바로 다음 레벨에 $P_x < K_x ≤ R_x$를 만족하는 노드 $K$가 있다면 $K$는 노드 $P$의 오른쪽 자식이 되며, 노드 $K$의 자식 노드가 가질 수 있는 $x$의 범위는 $P_x + 1 ≤ x ≤ R_x (x ≠ K_x)$가 됩니다.
>
> 위 과정을 재귀적으로 반복하면서 각 노드의 왼쪽, 오른쪽 자식을 찾아주면 트리를 구성할 수 있습니다.
>
> 노드별 왼쪽, 오른쪽 자식을 찾는 방법은 여러 가지가 있을 수 있습니다. 
> 
> 그중 하나로, 재귀적으로 순회하며 트리를 만들면 같은 level의 노드는 $x$값이 작은 노드부터 방문하게 되므로, 큐를 트리의 레벨만큼 만들어 두고, $x$축 기준으로 오름차순 정렬된 노드들을 $y$축 값이 같은 노드끼리 각 큐에 넣어두면 큐의 front를 확인하는 방법으로 O(1)에 찾을 수 있습니다.
>
> 이렇게 하면 노드의 수가 $N$일 때, 트리를 구성하는 데는 $O(N)$시간이 소요되며, 시간 복잡도는 전체 노드를 정렬하는데 걸리는 시간인 $O(NlogN)$이 됩니다.

![길찾기게임결과](./길%20찾기%20게임%20결과.png)