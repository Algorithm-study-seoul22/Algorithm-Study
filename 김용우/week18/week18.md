# 위상 정렬
위상 정렬은 방향이 있는 그래프를 정렬하는 방법이다.  
기본적인 방법은 방향이 있는 그래프를 구성하는 것과 같이  
&nbsp;edge[앞 정점].push_back[뒤 정점]  
과 같이 구성한다.  

위상 정렬의 경우 여기서 "진입 차수"라는 것을 사용하여 구현이 가능하다.  
진입 차수란? 현재 정점으로 들어오는 (앞 순서여야 하는) 간선의 개수라고 이해했다.  
따라서 위의 예시를 따라 간다면, 뒤 정점에 앞 정점이 연결되어 있으므로  
&nbsp;inDegree[뒤 정점]++  
와 같이 구성한다.  

이제 그래프의 연결 정보와 진입 차수를 구했으므로 순서에 맞게 위상 정렬을 할 수 있다.  
진입 차수가 0인 정점을 출력하도록 하면 위상 정렬이 된다. (진입 차수가 0이면 앞 순서 정점이 없단 소리)  
보다 구체 적으로, 다음과 같이 반복 된다.  
&nbsp;1. 진입 차수가 0인 정점 A  
&nbsp;2. 정점 A와 연결외어 있는 정점 B -> B = edge[A][i], (0<= i < edge.size())  
&nbsp;3. B의 진입 차수 감소 -> inDegree[B]--;  
&nbsp;4. B의 진입 차수가 0이라면, 순위 후보에 넣음  
&nbsp;5. 반복 1 ~ 4  

다른 문제를 풀며 알게 된 점은  
&nbsp;* 큐에 1개의 정점이 들어 있어야 순서가 확실 -> 1개 이상이면 여러가지 순서가 나올 수 있음  
&nbsp;* 큐에 우선 순위를 주어 원하는 답을 출력 -> 더 작은 번호의 노드를 우선 순위에 두는 둥  
&nbsp;* 모든 정점이 순서에 연결되지 않는 경우 -> 그래프의 컴포넌트(즉, 연결되어 있지 않음)가 생긴 경우가 있음  
와 같다.  

# 최단 거리 찾기  
## 벨만-포드  
벨만-포드는 간선의 값이 음수일 때도 사용할 수 있다.  
다익스트라를 사용하면 간선의 값이 음수일 경우 올바른 값이 나오지 않는다.(실제 세계에서 도로는 음의 값을 갖기 어려우므로 실제 세계에서 사용할 일은 많아 보이지 않는다!)  

벨만-포드는 다음과 같이 동작한다.  
&nbsp;1. 총 노드의 개수 만큼 반복한다.
&nbsp;2. 반복의 한 사이클은 모든 노드에 대하여 연결되어 있는 간선의 수만큼 반복한다.
&nbsp;3. 마지막 노드의 개수 번째 반복 때 갱신되는 간선 정보가 있다면 음의 사이클이 있음을 의미한다.

아직 벨만-포드의 대한 개념이 잘 정리 되지 않았다.  

## 플로이드-워셜  
모든 정점과 정점 사이의 거리를 구하여 최단 경로를 구하는 방법이다.  
즉, 모든 정점 간의 거리를 빠르게 구하고 싶다면 플로이드-워셜을 사용하면 된다.  
3중 for문을 사용하여 구현한다.  

노드 A에서 노드 B로 가는데 필요한 값을 C라고 하면
&nbsp;arr[A][B] = C  
와 같이 나타낼 수 있다.

내가 생각하기에 플로이드-워셜에서 가장 중요한 개념은 "경유지"라고 생각한다.  
"A에서 B를 이동할 때 경유지인 T를 거친다면 더 빠른가?" 가 중요한 개념이다.  
출발지 A와 도착지 B, 경유지 T1, T2, T3가 있다고 가정하자.  
출발지에서 도착지까지 바로 가는 경로보다 T1을 경유하는 경로가 더 짧다면, A - T1 - B의 값을 arr[A][B]에 저장한다.  
똑같은 방식으로 T1을 경우하는 경로보다 T2를 경유하는 경로가 더 짧다면, A - T2 - B의 값을 arr[A][B]에 저장한다.  
중간 경유지가 T2와 T3으로 한 개 이상인 경우에도, A - T1 - T2 - B의 경로는 arr[A][B]에 저장된다.  

