# Week 06 (23.03.13 ~ 23.03.19)

## 핀볼 게임

### 접근 방법

- 모든 좌표를 확인하며 빈 공간이라면 모든 방향으로 시뮬레이션

### 구현 내용

- `wormhole` : 웜홀 번호에 해당하는 웜홀 쌍의 좌표
- `blockDir[블록 번호][진행 방향]` : 블록 번호와 진행 방향에 따른 변화된 방향
- 웜홀은 6~10의 번호를 가지므로 11의 크기로 초기화
- 게임판 주변을 5번 블록으로 울타리 치기
- 입력 받으며 웜홀 번호에 해당하는 좌표 정보 저장
- 모든 좌표를 확인하며 빈 공간이라면 모든 방향으로 게임 진행
  - 출발 위치로 돌아오면 게임이 끝난다. → 출발 위치를 블랙홀로 만든다.
  - `while(true)`
    - 진행 방향으로 한 칸 이동
    - 블랙홀에 빠지면 게임 끝 → break
    - 1~5번 블록이라면
      - 블록 번호와 진행 방향에 해당하는 방향 변화
      - 점수 획득
    - 6~10번 웜홀이라면
      - 웜홀 번호에 해당하는 좌표 쌍 중 반대편 웜홀 좌표 찾기
      - 반대편 웜홀로 이동
  - 출발 위치를 빈 공간으로 복구

## 연구소 3

### 접근 방법

- M개의 바이러스를 활성 상태로 변경한다. → DFS
- 바이러스를 퍼뜨린다. → BFS

### 구현 내용

- `virus` : 바이러스 좌표
- `selected` : 활성 상태로 변경할 바이러스 번호
- `emptyCnt` : 연구소 전체 빈 칸 수
- 입력을 받으며
  - 바이러스 좌표 저장
  - 연구소 전체 빈 칸 개수 count
- 전체 바이러스 중 M개를 선택해 활성 상태로 변경(dfs)
  - `level` : 선택한 바이러스 개수
  - `last` : 이전에 선택했던 바이러스 번호
  - 이전에 선택했던 바이러스 이후부터 바이러스 선택
  - M개의 바이러스를 선택했다면 바이러스 퍼뜨리기
- 바이러스 퍼뜨리기(bfs)
  - `spreadCnt` : 바이러스를 퍼뜨린 빈 칸 개수
  - 활성 상태로 변경된 M개의 바이러스를 queue에 넣고 방문 체크
  - queue가 빌 때까지
    - 연구소 전체 빈 칸에 바이러스를 퍼뜨렸다면 정답 갱신 후 return
    - 시간(hour) 증가
    - 지금까지 찾은 정답보다 많은 시간이 걸리면 return
    - 단계별 flood fill
      - 빈 공간이라면 바이러스를 퍼뜨린 빈 칸 개수 증가

## 안정적인 전압

### 접근 방법

- 부분합 + DAT

### 구현 내용

- `volt` : 전압
- `psum[now]` : 0번 idx부터 now번 idx까지의 전압 부분합
- `zeroCnt[now]` : 0번 idx부터 now번 idx까지의 전압 부분합 중 0의 개수
- `um` : 전압 부분합에서 해당 숫자가 몇 번 나왔는지 count할 `unordered_map`
- 부분합 계산, 부분합 중 0의 개수 count
- 아무것도 조작하지 않았을 때 전압이 0으로 만들어지는 횟수로 ans값 갱신
- 뒤에서부터 앞으로 확인하면서
  - 현재 부분합 숫자가 한 번 나왔다고 count
  - 전압이 0이라면 조작해도 변화가 없으니 continue
  - `zeroCnt[i]` : 0번부터 i번까지의 전압 부분합 중 0의 개수
  - `um[volt[i]]` : i번 volt를 0으로 만들었을 때 i번 이후의 0의 개수
    - i번 volt를 0으로 만들면 i번 volt와 같은 부분합이 0이 된다.
  - i번 volt를 0으로 만들었을 때 0의 개수는 `zeroCnt[i] + um[volt[i]]`
  - 정답 갱신

## 표 병합

### 접근 방법

- 셀 병합 → Union-Find
- 2차원 표를 1차원으로 변경해서 사용

### 구현 방법

- `table` : 해당 셀에 저장된 string 데이터 (2차원 표를 1차원으로 변경해서 사용)
- `parent` : Union-Find에서 사용할 부모 정보
- `pos2idx(int y, int x)` : (y, x) 좌표값을 1차원 index로 변경
- 모든 명령어 실행
  - 명령어 parsing
  - `UPDATE`
    - (r, c) 위치의 셀 선택 (명령어 개수 4개)
      - 좌표를 index로 변경
      - 모든 데이터는 최상단 부모가 가지고 있으므로 Find 사용
      - 선택한 셀의 값을 value로 변경
    - value1을 값으로 가지고 있는 모든 셀 선택
      - table의 모든 index 확인
      - 최상단 부모가 가지고 있는 값이 value1이라면 value2로 변경
  - `MERGE`
    - (r1, c1)위치의 셀과 (r2, c2)위치의 셀 병합 → Union
      - MERGE 할 때 앞의 셀 기준으로 병합
      - 앞의 셀 값이 비어있고 뒤의 셀이 값을 가지고 있으면 병합된 셀은 그 값을 가지게 된다.
      - 최상단 부모만 데이터를 가지고 있을 수 있도록 뒤의 셀 clear
  - `UNMERGE`
    - 선택한 셀의 최상단 부모 찾기
    - 병합 해제 전 셀의 값 저장 후 clear
    - `target` : 병합 해제할 셀의 index를 담을 vector
    - 모든 index를 확인하며 선택한 셀과 같은 그룹이면 target에 push
    - target에 있는 index의 parent를 자기 자신으로 초기화
    - 병합 해제 전 셀이 값을 가지고 있었을 경우 (r, c) 위치의 셀이 그 값을 가지게 된다.
  - `PRINT`
    - 선택한 셀의 최상단 부모가 가지고 있는 값을 찾는다.
    - 그 값이 비어있다면 "EMPTY"를 answer에 넣고, 아니라면 해당 값을 answer에 넣는다.

