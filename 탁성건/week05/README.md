# Week 05 (23.03.06 ~ 23.03.12)

## 프로세서 연결하기

### 접근 방법

- Core의 전원을 연결할 수 있는 모든 경우의 수 확인 → DFS

### 구현 내용

1. 멕시노스의 초기 상태를 입력받으면서 Core 위치를 vector에 저장
   - 가장자리에 위치한 Core는 이미 전원이 연결된 상태이므로 skip
2. DFS를 통해 Core를 하나씩 확인하면서
   1. 현재 Core의 전원을 연결하지 않고 다음 Core로 넘어감
   2. 상하좌우 4방향으로 연결해보기
      - 현재 방향으로 전선을 연결하면서 갈 수 있는 만큼 이동(빈 공간일 경우 이동)
      - 코어, 전선, 가장자리를 만나는 경우 stop
      - 만약 전선이 가장자리를 만나 현재 Core에 전원을 연결할 수 있다면
        - 전원이 연결된 Core 개수 증가
        - 현재 Core를 연결하는데 필요한 전선의 길이 더하기
        - 다음 Core로 넘어감
      - 현재 Core에 연결했던 전선 제거
   3. 모든 Core에 대해서 선택을 완료했을 경우 정답 갱신

## 머리 맞대기

### 접근 방법

- HeadSum의 MAX값이 가장 작게 나오도록 T개의 팀을 구성했을 때의 HeadSum의 MAX값

  → 정답이라고 가정한 HeadSum의 MAX값을 기준으로 T개 이하의 팀을 구성할 수 있는지 확인하면서 가장 작은 HeadSum의 MAX값 찾기

  → Parametric Search

### 구현 내용

1. 사람들의 두뇌 회전 속도를 입력받으면서
   - 모든 사람의 두뇌 회전 속도 합 구하기
   - 한 사람의 두뇌 회전 속도 최대값 구하기
2. 원탁에 앉아있으므로 두뇌 회전 속도 배열 뒤에 똑같은 배열 복사
3. Parametric Search
   1. 팀 구성시 가정할 수 있는
      - 가장 작은 HeadSum의 MAX값은 한 사람의 두뇌 회전 속도 최대값(개인 팀) → left
      - 가장 큰 HeadSum의 MAX값은 모든 사람의 두뇌 회전 속도 합(모든 사람이 한 팀) → right
   2. mid는 정답이라고 가정한 HeadSum의 MAX값
   3. 정답이라고 가정한 HeadSum의 MAX값을 기준으로
      1. T개 이하의 팀을 구성할 수 있는지 확인
         1. 원탁에 앉아 있으니 0부터 N-1까지의 사람을 시작으로 팀을 구성할 수 있는 모든 경우의 수 확인
         2. N명의 사람을 target을 기준으로 팀 구성
            1. 팀을 구성했을 때 target을 넘지 않으면 팀원에 포함
            2. 팀을 구성했을 때 target을 넘으면 새로운 팀 구성
            3. 마지막 남은 그룹 확인
         3. target을 기준으로 T개 이하의 팀을 구성할 수 있으면 true 반환
         4. target을 기준으로 T개 이하의 팀을 구성할 수 없으면 false 반환
      2. T개 이하의 팀을 구성할 수 있다면 정답을 갱신하고 더 작은 HeadSum의 MAX값 찾기
      3. T개 이하의 팀을 구성할 수 없다면 더 큰 HeadSum의 MAX값 찾기
   4. 정답(HeadSum의 MAX값이 가장 작게 나오도록 T개의 팀을 구성했을 때의 HeadSum의 MAX값) 반환

## 코딩 테스트 공부(Bottom-Up)

### 접근 방법

- 모든 문제를 다 풀 수 있는 알고력과 코딩력을 얻는 최단시간 구하기 → Dynamic Programming

### 구현 내용

1. `dp[알고력][코딩력]` : 해당 알고력과 해당 코딩력을 얻기 위해 필요한 최단 시간

2. 알고리즘 공부와 코딩 공부를 problems vector에 추가

   - 알고리즘 공부 → 알고력 1을 높이기 위해 1의 시간 필요
   - 코딩 공부 → 알고력 1을 높이기 위해 1의 시간 필요

3. 처음부터 모든 문제를 다 풀 수 있는 경우가 있으므로 목표 알고력과 목표 코딩력을 초기 알고력과 초기 코딩력으로 초기화

4. 문제들을 확인하면서 목표 알고력과 목표 코딩력 갱신

5. dp를 최대값으로 초기화

6. 초기 알고력과 초기 코딩력을 얻기 위해 필요한 시간은 0

7. 모든 알고력과 모든 코딩력에 대해서 모든 문제들을 확인

   1. 문제를 풀 수 없으면 skip

   2. 문제를 풀었을 때 얻을 수 있는 다음 알고력과 다음 코딩력 계산

      - 목표 알고력과 목표 코딩력을 넘어가지 않도록 처리

   3. 다음 알고력과 다음 코딩력을 얻기 위해 필요한 시간

      = 현재 알고력과 현재 코딩력을 얻기 위해 필요한 시간 + 현재 문제를 푸는데 드는 시간

   4. 다음 알고력과 다음 코딩력을 얻기 위해 필요한 시간이 이미 기록된 값보다 작다면 최소값으로 갱신

8. 목표 알고력과 목표 코딩력을 얻기 위해 필요한 최단 시간 return

## 코딩 테스트 공부(Top-Down)

### 접근 방법

- 모든 문제를 다 풀 수 있는 알고력과 코딩력을 얻는 최단시간 구하기 → Dynamic Programming

### 구현 내용

1. `dp[알고력][코딩력]` : 현재 알고력과 현재 코딩력이 있을 때 목표 알고력과 목표 코딩력을 얻기 위해 필요한 최단 시간
2. 알고리즘 공부와 코딩 공부를 problems vector에 추가
   - 알고리즘 공부 → 알고력 1을 높이기 위해 1의 시간 필요
   - 코딩 공부 → 알고력 1을 높이기 위해 1의 시간 필요
3. 처음부터 모든 문제를 다 풀 수 있는 경우가 있으므로 목표 알고력과 목표 코딩력을 초기 알고력과 초기 코딩력으로 초기화
4. 문제들을 확인하면서 목표 알고력과 목표 코딩력 갱신
5. dp를 -1로 초기화
6. `dfs(알고력, 코딩력, problems)` : 현재 알고력과 현재 코딩력이 있을 때 목표 알고력과 목표 코딩력을 얻기 위해 필요한 최단 시간은 얼마인가?
   1. 만약 목표 알고력과 목표 코딩력에 도달했다면 0을 return (기저 조건)
   2. 만약 dp에 이미 기록된 값이 있다면(이미 문제를 푼 적이 있다면) 기록된 답을 return
   3. 최단 시간을 구하기 위해 res값을 최대값으로 초기화(res는 현재 문제의 답을 저장할 변수)
   4. 모든 문제들을 확인하면서
      1. 만약 풀 수 없는 문제라면 skip
      2. 현재 문제를 풀었을 때 얻을 수 있는 다음 알고력과 다음 코딩력 계산
         - 목표 알고력과 목표 코딩력을 넘지 않도록 처리
      3. 만약 문제를 풀었을 때 알고력과 코딩력이 변하지 않고 그대로라면 skip
      4. 현재 문제를 풀었을 때 목표 알고력과 목표 코딩력을 얻기 위해 필요한 최단 시간 계산
         - 다음 알고력과 다음 코딩력이 있을 때 목표 알고력과 목표 코딩력을 얻기 위해 필요한 최단 시간 + 현재 문제를 푸는데 드는 시간
      5. res값 갱신(최소값 찾기)
   5. dp에 현재 문제의 정답인 res를 저장하고 해당 값 return

