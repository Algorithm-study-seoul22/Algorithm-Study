# Week 08 (23.03.27 ~ 23.04.02)

## 휴대폰 자판

### 접근 방법

- 문자열 저장 및 탐색 → 트라이(Trie)

### 구현 내용

- `Node` 구조체
  - `bool isEnd` : 문자열의 끝인가?
  - `int childCnt` : child의 개수
  - `Node *child[SIZE]` : child node를 가리킬 포인터 배열(0~25)
  - 생성자를 이용한 초기화
  - 소멸자를 이용한 동적 할당 해제
- `Trie` 클래스
  - `Node head` : Trie의 최상단 Node
  - `void insert(string str)`
    - `ptr` : Node를 가리킬 포인터. head를 가리키도록 초기화
    - 문자열을 처음부터 끝까지 확인하며
      - idx에 해당하는 child가 없다면 생성
        - childCnt 증가
      - `ptr`이 child node를 가리키도록 변경
    - 문자열의 끝 표시(`isEnd`)
  - `int find(string str)`
    - `ptr` : Node를 가리킬 포인터. 첫 글자부터 시작
    - `pushCnt` : 버튼을 누른 횟수. 첫 글자는 반드시 버튼을 눌러야 한다.
    - 모든 글자를 확인하며
      - 자식이 2개 이상이거나 다른 문자열의 끝인 경우 버튼을 눌러야 한다.
    - `pushCnt` 반환
  - `main`
    - N개의 단어를 Trie에 insert
    - N개의 단어를 Trie에서 find하며 버튼을 누른 횟수의 합 구하기
    - 버튼을 눌러야 하는 횟수의 평균 출력

## 나무 재테크

### 접근 방법

- deque를 이용한 시뮬레이션
  - 입력으로 주어지는 나무의 위치는 모두 서로 다르므로 초기 나무는 0개 아니면 1개
  - 새로 생길 나이가 1인 나무는 무조건 다른 나무들보다 어리다. → deque 앞에 추가

### 구현 내용

- `deque<int> tree[10][10]` : (y, x)에 있는 나무들의 나이
- `MAP[10][10]` : 땅의 양분. 가장 처음 양분은 5
- `A[10][10]` : 겨울에 추가되는 양분
- K년 동안 시뮬레이션
  - `die[y][x]` : (y, x)에서 죽은 나무로 인해 추가될 양분
  - `cnt[y][x]` : (y, x)에 생길 나이가 1인 나무의 개수
  - 모든 좌표를 확인하며
    - (y, x)에 있는 나무의 개수만큼 반복
      - `age` : 현재 나무의 나이(`front()`)
      - `pop_front()`
      - 나이만큼 양분을 먹을 수 없는 경우 죽어서 양분이 된다.
        - `die[y][x]`에 양분 추가
      - 양분을 충분히 먹을 수 있다면 양분을 먹고 나이 1 증가(`push_back()`)
      - 증가한 나이가 5의 배수라면 번식
        - `cnt[ny][nx]++` : (ny, nx)에 생길 나이가 1인 나무 개수 증가
  - 모든 좌표를 확인하며
    - 땅의 양분에 죽은 나무로 인해 추가될 양분과 겨울에 추가되는 양분을 더해준다.
    - 새로 생길 나이가 1인 나무는 무조건 다른 나무들보다 어리므로 앞에 추가한다.(`insert`)
- 모든 좌표를 확인하며 살아있는 나무 개수 count

## 미로 탈출 명령어

### 접근 방법

- Dynamic Programming + Greedy

### 구현 내용

- 방향 배열은 하(d), 좌(l), 우(r), 상(u)으로 사전순 배치
- `K` : 탈출까지 이동해야 하는 거리
- `dp[x][y][cnt]` : (x, y)에서 K-cnt번 움직일 수 있을 때 사전순으로 가장 빠른 탈출 경로 저장
- `string dfs(int x, int y, int cnt)` : (x, y)에서 K-cnt번 움직일 수 있을 때 사전순으로 가장 빠른 탈출 경로는?
  - K번 움직였을 때
    - (R, C)에 도착했다면 가능한 경우이므로 빈 문자열 반환
    - 도착하지 못했다면 정답이 될 수 없는, 사전순으로 가장 나중인 "z" 반환
  - 이미 문제를 해결한 경우가 있다면 기록된 값을 반환
  - `ret` : 현재 문제에 대한 정답. "z"로 초기화
  - 사전순으로 모든 방향 확인
    - `dfs(nx, ny, cnt + 1)` : (nx, ny)에서 K-(cnt+1)번 움직일 수 있을 때 사전순으로 가장 빠른 탈출 경로. 다음 문제에 대한 정답 → temp에 저장
    - temp가 "z"라면 목적지에 도달할 수 없는 경우이므로 continue
    - 현재 방향을 선택했을 경우의 정답은 `ch[i] + temp`
      - `ch[i]` : 현재 방향에 대한 문자
      - `temp` : 다음 문제에 대한 정답
    - 사전순으로 배치했으므로 정답 후보를 찾았으면 뒤에 있는 것은 더는 볼 필요가 없다. → break
- `dfs(x, y, 0)` : (x, y)에서 K번 움직일 수 있을 때 사전순으로 가장 빠른 탈출 경로는?
  - 도달할 수 없는 경우 "z" 반환 → "impossible"

